---
layout: ../../layouts/BlogLayout.astro
title: AstroのScriptタグを扱うときの注意
date: 2022-11-23
description: AstroでのScriptタグのパフォーマンスの問題と環境変数の扱い方について説明します。
image: /images/brands/astro.png
tags: javascript
---

import OG from "../../components/OG.astro";

Astro の`<script>`は何もインテグレーションを入れなくても使えるお手軽さがある一方、ハマるポイントがあります。

<OG url="https://docs.astro.build/en/core-concepts/astro-components/#client-side-scripts" />

## Script の問題点

以下のコードの場合、Header は共通で使われるものではあるものの Foo は条件により`/blog`以下でしか HTML 上には出力されません。
つまり、これは他のページではこの Foo.astro 自体が読み込まれないように期待したいところです。
しかし、これは上手くいきません。

```astro
---
// Foo.astro
---

<span>foo</span>

<script>
  console.log("hello");
</script>
```

<br />

```astro
---
// Header.astro

import Foo from "./Foo.astro";
---

<header>
  <p>site</p>
  {Astro.url.pathname.startsWith("/blog") && <Foo />}
</header>
```

実際の出力結果はこのようになります。このように**全てのページの HTML** にこの `<script>` が挿入されます。

![script as global on html](/images/blog/astro-script-issue/global-script-on-html.png)

なぜこのようになるかというと、`<script>`はデフォルトでグローバル(`is:global`)の扱いとなるためです。
たしかに Foo.astro の中で書いたものではあるものの、どこにでも影響を与えることができてしまうので、保証できずうまく最適化できません。

このサンプルの場合だと大きな影響はないですが、例えばライブラリを import したらどうでしょうか？

```astro
---
// Foo.astro
---

<span>foo</span>

<script>
  import { App } from "octokit";

  console.log("hello");
  console.log(App);
</script>
```

この場合は、ライブラリが hoisting され、HTML から分離されます。
このように、ライブラリと一緒の JS へユーザーランドのコードが入ります。

![hoisted js](/images/blog/astro-script-issue/hoisted.png)

例えこのように JS に分解されても、やはり扱いはグローバルなのでこの JS は全ての HTML で呼び出しが行われてしまいます。
これは`/blog`以外のページからすると見過ごせない無駄なコードとなり、最適化を行う必要があります。

これを回避するには、`is:inline`(or `define:vars`)をつけることにより、そのファイルのコンポーネントだけがスコープとなります。
しかし、次の問題は、これらはトランスパイラを通しません。つまり、絶対パスではない場合の import が読み込めなかったり、コード自体の最適化することができません。
また、これの一番致命的な点は、**TypeScript で書けない**点です。

---

現段階での結論としては、以下のようになります。

- TS を使いたい場合は、global を使う
- global は全てのページに挿入されるため、副作用がありえる
- バンドルサイズも共有されてしまうため、global では一部でしか使われないライブラリを使うべきではない

と、TS + Scope を実際にはやりたいわけですが、それを叶えるのは`<script>`だけでは厳しそうです。

では、どうすればよいのでしょうか？

## Framework を使う

今回は、React を例に見ていきます。

```ts
// Foo.tsx
import { App } from "octokit";
import type { FC } from "react";

export const Foo: FC = () => {
  console.log("hello");
  console.log(App);

  return <span>foo</span>;
};
```

<br />

```astro
---
// Header.astro

import Foo from "./Foo.astro";
---

<header>
  <p>site</p>
  {Astro.url.pathname.startsWith("/blog") && <Foo client:load />}
</header>
```

`client:load`を使い、React 等で閉じ込めると、以下のようになります。
これは、`/blog`以下でしかダウンロードされない JS となるため、期待通りの挙動となります。

![react](/images/blog/astro-script-issue/react.png)

## Env の扱い方

`import.meta.env`は Astro 標準で準備されているものしか`<script>`内では参照できません。
これを解決するには`define:vars`経由で入れる必要があります。
しかし、先程の話通り、`define:vars`は TS で書けなかったりバンドラを通しません。

### define:vars を利用する方法

```astro
---
const foo = import.meta.env.FOO;
---

<script define:vars={{ foo }}>
  console.log(import.meta.env.FOO); // これは存在しない
  console.log(foo);
</script>
```

これを回避する方法は、以下のように 1 段階 window に刺すレイヤーを用意して上げる方法です。

### Window でラップする方法

```astro
---
const foo = import.meta.env.FOO;
---

<script define:vars={{ foo }}>
  window.foo = foo;
</script>

<script>
  const foo: string = "foo";
  console.log(window.foo);
</script>
```

それか、Vite で回避する方法もあります。この問題自体は Vite の問題でセンシティブな情報が出てしまわないようにする制約です。

### .env でフロントエンドに渡したいものに`VITE_*`をつける方法

<OG url="https://vitejs.dev/guide/env-and-mode.html#env-files" />

<br />

```
VITE_SOME_KEY=123
DB_PASSWORD=foobar
```

<br />

```ts
console.log(import.meta.env.VITE_SOME_KEY); // 123
console.log(import.meta.env.DB_PASSWORD); // undefined
```

### define で定義してあげる方法

```ts
// vite.config.ts
import { defineConfig } from "vite";

export default defineConfig({
  define: {
    FOO: JSON.stringify(process.env.FOO),
  },
});
```

ただ基本、Astro を触っていると vite の設定は触らないのでこの書き方はあまり使わないかもしれません。

## まとめ

Astro は JS を削ぎ落として HTML を生成することに特化していますが、ブラウザで動く JS のコードを書く場合は、ライブラリに依存したほうが良いかなと思います。
特定の Astro ファイルに書いているので、そのコンポーネントのスコープのみの`<script>`になるかと思って書くとハマりがちです。
